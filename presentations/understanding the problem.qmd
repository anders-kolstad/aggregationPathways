---
title: "Understanding the problem of when to scale"
format: 
  revealjs:
    smaller: true
    scrollable: false
    preview-links: true
editor: visual
---

```{r setup}
library(knitr)
```

## This project

-   250 000 kr

-   166 hours

-   1 month

-   Manuscript on pre-print server

-   Produce guidelines

## Blåbærkrisa

::: columns
::: {.column width="50%"}

- Same data gave different indicator values.
- Reference values are at county scales (and probably only make sense at that scale)
- IBECA normalised the variables (with truncation) at plot scale
- NI normalised the variable (probably) at a regional scale after first taking a mean
:::

::: {.column width="50%"}

![](img/billberry.PNG){width=100%}

:::

:::

---


![](img/billberry_graph.PNG)

---

![](img/billberry_ibeca.PNG)

## It matters 
if we  aggregate (takes means of) of the scaled or unscaled variabel:

![](img/ASPT.png)

## Arguments for scaling and truncating immediately

- Positive (and negative) outliers in on area can not compensate for poor (or good) condition elsewhere
- Gives higher-resolution indicator values

## Arguments for scaling and truncating later at a level where the reference value is sensible

- The reference value was maybe intended for that scale
- The indicator uncertainty becomes (apparently) smaller because the mean or sum for a region is less variable.
- Maybe, to many truncation events leds to accumulated dissplacement errors?

## What if

- The reference value is at the same scale as the variable
- The reference value is the same all over
- We scale locally before aggregating, and then truncate later
- We also want to aggregate the original variable further, e.g. to national level - will the indicator and variable remain correlated

## Resources

[Sanvik 2019](https://brage.nina.no/nina-xmlui/handle/11250/2631056)


## Why do we re-scale
*notes from Bård*

Reference values serve two purposes

- to enable rescaling to a common measurement scale to facilitate the calculation of the mean.
-	to set a limit for how much one indicator can compensate for other indicators being in a bad state.

As a consequence, an index of rescaled indicators summarizes **negative deviations** from the reference state over a large set of indicators. 

Unscaled states above the reference value are not recognized as being better than the reference state.

Rescaling is useful for making indeces, but why use it for individual indicators? [answer: it depends if we want to aggregate 'condition estimates' of actuall measurements]






## Spatially aggregating 
condition estimates (bottom) or actuall measurements (top)

```{r}
source("../R/example1.R")
example1
```

::: aside
Indicators with grey background
:::


------------------------------------------------------------------------

## Early scaling 
leads to cummutativity 

```{r}
#| fig-align: "left"
#| fig-height: 6
#| fig-width: 7
source("../R/example3.R")
example3
```

------------------------------------------------------------------------

## Early scaling 
leads to cummutativity 

```{r}
#| fig-align: "left"
#| fig-height: 6
#| fig-width: 7
source("../R/example4.R")
example4
```

------------------------------------------------------------------------

## Also with area weighting

```{r}
#| fig-align: "left"
#| fig-height: 6
#| fig-width: 7
source("../R/example3b.R")
example3b
```

------------------------------------------------------------------------

## Also with area weighting

```{r}
#| fig-align: "left"
#| fig-height: 6
#| fig-width: 7
source("../R/example5.R")
example5
```

## Commutativty


![](img/commutativity.PNG)

## Alternativey,
we can aggregate the actual measurements. When would this make sense to do?

```{r}
#| fig-align: "left"
#| fig-height: 6
#| fig-width: 7
source("../R/example6.R")
example6
```

------------------------------------------------------------------------

## Same, but with no area weighting and taking the sum (e.g. population sizes)

```{r}
#| fig-align: "left"
#| fig-height: 6
#| fig-width: 7
source("../R/example7.R")
example7
```

## What about

- Scaling, aggregating, and then truncating
- Non-linear re-scaling functions with asymptotes
